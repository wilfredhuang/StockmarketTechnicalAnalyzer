[
    {
        "label": "pandas_ta",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas_ta",
        "description": "pandas_ta",
        "detail": "pandas_ta",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "plotly.graph_objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.graph_objects",
        "description": "plotly.graph_objects",
        "detail": "plotly.graph_objects",
        "documentation": {}
    },
    {
        "label": "plotly",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly",
        "description": "plotly",
        "detail": "plotly",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "plotly",
        "description": "plotly",
        "isExtraImport": true,
        "detail": "plotly",
        "documentation": {}
    },
    {
        "label": "plotly.express",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.express",
        "description": "plotly.express",
        "detail": "plotly.express",
        "documentation": {}
    },
    {
        "label": "dumps",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "LinearRegression",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "MinMaxScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "yfinance",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yfinance",
        "description": "yfinance",
        "detail": "yfinance",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "current_app",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Fore",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Style",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "create_app",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "visualise_analysis",
        "kind": 2,
        "importPath": "app.helpers.graph_for_analysis",
        "description": "app.helpers.graph_for_analysis",
        "peekOfCode": "def visualise_analysis(csv_filename, company):\n    #main graph \n    data = pd.read_csv(f\"app/static/data/{csv_filename}\")\n    data = data.loc[data['Symbol'] == company]\n    fig = go.Figure(data = \n                    [go.Candlestick(x=data.index,\n                    open=data['Open'],\n                    high=data['High'],\n                    low=data['Low'],\n                    close=data['Close'],",
        "detail": "app.helpers.graph_for_analysis",
        "documentation": {}
    },
    {
        "label": "visualise_prediction",
        "kind": 2,
        "importPath": "app.helpers.graph_for_analysis",
        "description": "app.helpers.graph_for_analysis",
        "peekOfCode": "def visualise_prediction(prediction_data, historical_data):\n    fig = px.line(prediction_data, x=\"Date\", y=\"Results\", title='Stock Prices')\n    fig.add_trace(go.Scatter(x=historical_data['Date'], y=historical_data['Close'],mode='lines',name='Historical Data',line=dict(color='yellow')))\n    plot_json = plotly.io.to_json(fig, pretty=True)\n    return plot_json",
        "detail": "app.helpers.graph_for_analysis",
        "documentation": {}
    },
    {
        "label": "load_data",
        "kind": 2,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "def load_data(tickers: List[str]) -> pd.DataFrame:\n    pass\ndef visualize(ticker, indicators: List[str]):\n    pass\ndef compute_indicators(df: pd.DataFrame, indicators: List[str]) -> pd.DataFrame:\n    pass\ndef rank_stocks(tickers: pd.DataFrame) -> pd.DataFrame:\n    # TO DO: logic to rank the stocks according to some rule using information from the indicators\n    # returns the tickers and their ranking 1 to N\n    # to be shown to user as a suggestion",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "visualize",
        "kind": 2,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "def visualize(ticker, indicators: List[str]):\n    pass\ndef compute_indicators(df: pd.DataFrame, indicators: List[str]) -> pd.DataFrame:\n    pass\ndef rank_stocks(tickers: pd.DataFrame) -> pd.DataFrame:\n    # TO DO: logic to rank the stocks according to some rule using information from the indicators\n    # returns the tickers and their ranking 1 to N\n    # to be shown to user as a suggestion\n    pass\ndef test_stocks(tickers: List[str]) -> pd.DataFrame:",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "compute_indicators",
        "kind": 2,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "def compute_indicators(df: pd.DataFrame, indicators: List[str]) -> pd.DataFrame:\n    pass\ndef rank_stocks(tickers: pd.DataFrame) -> pd.DataFrame:\n    # TO DO: logic to rank the stocks according to some rule using information from the indicators\n    # returns the tickers and their ranking 1 to N\n    # to be shown to user as a suggestion\n    pass\ndef test_stocks(tickers: List[str]) -> pd.DataFrame:\n    # using the tickers that the user has chosen\n    # mimic what happened if the user had bought/traded them (testing with the last one year data)",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "rank_stocks",
        "kind": 2,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "def rank_stocks(tickers: pd.DataFrame) -> pd.DataFrame:\n    # TO DO: logic to rank the stocks according to some rule using information from the indicators\n    # returns the tickers and their ranking 1 to N\n    # to be shown to user as a suggestion\n    pass\ndef test_stocks(tickers: List[str]) -> pd.DataFrame:\n    # using the tickers that the user has chosen\n    # mimic what happened if the user had bought/traded them (testing with the last one year data)\n    # uses the backtest function\n    pass",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "test_stocks",
        "kind": 2,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "def test_stocks(tickers: List[str]) -> pd.DataFrame:\n    # using the tickers that the user has chosen\n    # mimic what happened if the user had bought/traded them (testing with the last one year data)\n    # uses the backtest function\n    pass\ndef backtest(tickers: pd.DataFrame):\n    pass\ndef train_linear_model(csvFile):\n    df = pd.read_csv(f\"app/static/data/{csvFile}\")\n    df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d')",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "backtest",
        "kind": 2,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "def backtest(tickers: pd.DataFrame):\n    pass\ndef train_linear_model(csvFile):\n    df = pd.read_csv(f\"app/static/data/{csvFile}\")\n    df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d')\n    #Split dataset by company\n    stock_list = df['Symbol'].unique() \n    frames = []\n    for stock in stock_list:\n        x = df.loc[df['Symbol'] == stock] ",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "train_linear_model",
        "kind": 2,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "def train_linear_model(csvFile):\n    df = pd.read_csv(f\"app/static/data/{csvFile}\")\n    df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d')\n    #Split dataset by company\n    stock_list = df['Symbol'].unique() \n    frames = []\n    for stock in stock_list:\n        x = df.loc[df['Symbol'] == stock] \n        #Shift close price (so the row for 1 Jan 2024 will contain the closing price for 11 Jan 2024)\n        x['Close'] = df.Close.shift(-10) ",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "predict_linear_model",
        "kind": 2,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "def predict_linear_model(company, date, csvFile, model):\n    df = pd.read_csv(f\"app/static/data/{csvFile}\")\n    df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d')\n    predict_set = df.loc[df['Symbol'] == company]\n    # Filter for historical data up to the previous day\n    historical_set = predict_set[-20:]\n    historical_set = historical_set[['Date','Close']]\n    predict_set = predict_set[-10:]\n    x_predict = predict_set[['Open','High','Low','Volume']]\n    y_score = model.predict(x_predict)",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "test_linear_model",
        "kind": 2,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "def test_linear_model(company, date, csvFile, model):\n    df = pd.read_csv(f\"app/static/data/{csvFile}\")\n    test_set = df.loc[df['Symbol'] == company]\n    test_set['Date'] = pd.to_datetime(test_set['Date'], format='%Y-%m-%d') \n    test_set['FutureClose'] = test_set.Close.shift(-10) \n    test_set.drop(test_set.tail(10).index,inplace=True)    \n    test_set = test_set.loc[test_set['Date'] >= date]\n    x_test = test_set[['Open','High','Low','Volume']]\n    y_test = test_set['FutureClose']\n    y_score = model.score(x_test,y_test)",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "model = train_linear_model('stock_data_20240925_124231.csv')\npredictions = predict_linear_model('AAPL','2023-08-02','stock_data_20240925_124231.csv', model)",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "predictions",
        "kind": 5,
        "importPath": "app.helpers.process_utils",
        "description": "app.helpers.process_utils",
        "peekOfCode": "predictions = predict_linear_model('AAPL','2023-08-02','stock_data_20240925_124231.csv', model)",
        "detail": "app.helpers.process_utils",
        "documentation": {}
    },
    {
        "label": "fetch_and_process_stock_data",
        "kind": 2,
        "importPath": "app.helpers.stock_utils",
        "description": "app.helpers.stock_utils",
        "peekOfCode": "def fetch_and_process_stock_data():\n    # List of 20 U.S. stocks (you can modify this list)\n    stocks = ['AAPL', 'MSFT', 'AMZN', 'GOOGL', 'FB', 'TSLA', 'BRK-B', 'JPM', 'JNJ', 'V', 'PG', 'UNH', 'MA', 'NVDA', 'HD', 'DIS', 'BAC', 'ADBE', 'CRM', 'NFLX']\n    end_date = datetime.now()  # Current date OR datetime(2024, 1, 1) - 01/01/24\n    start_date = end_date - timedelta(days=3652)  # Approximately 10 years\n    all_data = []\n    for stock in stocks:\n        ticker = yf.Ticker(stock)\n        data = ticker.history(start=start_date, end=end_date)\n        data['Symbol'] = stock",
        "detail": "app.helpers.stock_utils",
        "documentation": {}
    },
    {
        "label": "logger_middleware",
        "kind": 2,
        "importPath": "app.middleware.logger",
        "description": "app.middleware.logger",
        "peekOfCode": "def logger_middleware():\n    # Skip logging for static files\n    if request.path.startswith('/static'):\n        return\n    method_colors = {\n        'GET': Fore.GREEN,\n        'POST': Fore.BLUE,\n        'PUT': Fore.YELLOW,\n        'DELETE': Fore.RED\n    }",
        "detail": "app.middleware.logger",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app.middleware.logger",
        "description": "app.middleware.logger",
        "peekOfCode": "app = Flask(__name__)\n# Set up basic logging configuration\nlogging.basicConfig(level=logging.INFO, format='%(message)s')\n# Custom logger function\ndef logger_middleware():\n    # Skip logging for static files\n    if request.path.startswith('/static'):\n        return\n    method_colors = {\n        'GET': Fore.GREEN,",
        "detail": "app.middleware.logger",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "app.routes.main",
        "description": "app.routes.main",
        "peekOfCode": "def index():\n    # Initialize variable with env value [the direct way from .env file]\n    # secret_key = os.getenv('SECRET_KEY', 'default')\n    # Initialize variable with env value [get a variable value from the current config set]\n    secret_key = current_app.config.get('SECRET_KEY', 'default123')\n    # Define render variables\n    render_variables = {\n        'secret_key': secret_key,\n        'user_name': 'John Doe',\n    }",
        "detail": "app.routes.main",
        "documentation": {}
    },
    {
        "label": "grid_page",
        "kind": 2,
        "importPath": "app.routes.main",
        "description": "app.routes.main",
        "peekOfCode": "def grid_page():\n    # Define render variables\n    render_variables = {\n    }\n    return render_template('grid.html', **render_variables)\n# # Retrieve historical data for analysis\n# @main_bp.route('/get-analysis', methods=['POST'])\n# def get_analysis():\n#     try:\n#         company = request.form['company']",
        "detail": "app.routes.main",
        "documentation": {}
    },
    {
        "label": "main_bp",
        "kind": 5,
        "importPath": "app.routes.main",
        "description": "app.routes.main",
        "peekOfCode": "main_bp = Blueprint('main', __name__)\n@main_bp.route('/')\ndef index():\n    # Initialize variable with env value [the direct way from .env file]\n    # secret_key = os.getenv('SECRET_KEY', 'default')\n    # Initialize variable with env value [get a variable value from the current config set]\n    secret_key = current_app.config.get('SECRET_KEY', 'default123')\n    # Define render variables\n    render_variables = {\n        'secret_key': secret_key,",
        "detail": "app.routes.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "run",
        "description": "run",
        "peekOfCode": "app = create_app()\nif __name__ == '__main__':\n    # Get the debug mode variable based on current configuration\n    debug_mode = app.config.get('DEBUG', False)\n    app.run(debug=debug_mode)",
        "detail": "run",
        "documentation": {}
    }
]